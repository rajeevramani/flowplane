### Variables
@base_url = http://localhost:8080

# Setup token (shown in startup banner on first run)
# Format: fp_setup_{uuid}.{secret}
# Add to .env file: SETUP_TOKEN=fp_setup_...
@setup_token = {{$dotenv SETUP_TOKEN}}

# Admin token (obtained from bootstrap initialization)
# Format: fp_pat_{uuid}.{secret}
# Add to .env file: API_TOKEN=fp_pat_...
@admin_token = {{$dotenv API_TOKEN}}

### ============================================================================
### COMPLETE AUTHENTICATION FLOW (Follow this sequence)
### ============================================================================

### STEP 1: Bootstrap Initialization - First-Time Setup
### ----------------------------------------------------------------------------
# This is the FIRST step when setting up a new Flowplane instance.
# Exchange the setup token (from startup banner) for an admin token.
#
# After successful bootstrap:
# - The setup token is automatically revoked (can't be reused)
# - You receive an admin token with full access (admin:all scope)
# - Save the returned token securely!
###
# @name bootstrap

POST {{base_url}}/api/v1/bootstrap/initialize
Content-Type: application/json

{
  "adminEmail": "admin@example.com"
}

### Extract admin token from bootstrap response
@admin_token_from_bootstrap = {{bootstrap.response.body.setupToken}}

### ============================================================================
### SESSION MANAGEMENT WORKFLOW (Web-Based Authentication)
### ============================================================================
# For web applications, use session-based authentication with cookies and CSRF tokens.
# This provides secure, browser-friendly authentication with automatic cookie handling.

### STEP 2: Create Session Token
### ----------------------------------------------------------------------------

# Exchange a setup token for a 24-hour session token.
#
# What you receive:
# - Session cookie (fp_session) - HttpOnly, Secure, SameSite=Strict
# - CSRF token (X-CSRF-Token header) - Required for state-changing requests
# - Session ID, teams, scopes, and expiration time
#
# The session cookie is automatically set by the server.
###
# @name createSession

POST {{base_url}}/api/v1/auth/sessions
Content-Type: application/json

{
  "setupToken": "{{admin_token_from_bootstrap}}"
}

### Extract session details from response
# Note: The session token is in the Set-Cookie header, not in the response body
# Most HTTP clients automatically handle cookies, so you don't need to extract it manually
@csrf_token = {{createSession.response.body.csrfToken}}
@session_id = {{createSession.response.body.sessionId}}

### STEP 3: Get Session Info (Using Session Cookie)
### ----------------------------------------------------------------------------

# Retrieve information about the current session.
#
# The fp_session cookie is automatically sent by the HTTP client
# (it was set by the Set-Cookie header in the previous response)
#
# Returns: session ID, teams, scopes, expiration time
###
# @name getSessionInfo
GET {{base_url}}/api/v1/auth/sessions/me

### Alternative: Get Session Info with Explicit Cookie
# If your HTTP client doesn't automatically handle cookies, specify it manually:
# The cookie value is from the Set-Cookie header: fp_session=fp_session_{uuid}.{secret}
GET {{base_url}}/api/v1/auth/sessions/me
Cookie: fp_session={{$dotenv SESSION_TOKEN}}

### STEP 4: Make Authenticated Request with CSRF Protection
### ----------------------------------------------------------------------------
# For state-changing requests (POST, PUT, PATCH, DELETE):
# - Session cookie is sent automatically by the HTTP client
# - MUST include X-CSRF-Token header
#
# Example: Create a cluster using session authentication
###
POST {{base_url}}/api/v1/clusters
X-CSRF-Token: {{csrf_token}}
Content-Type: application/json

{
  "name": "example-cluster",
  "endpoints": [
    {
      "host": "api.example.com",
      "port": 443
    }
  ]
}

### STEP 5: Logout - End Session
### ----------------------------------------------------------------------------
# @name logout
# Revoke the session token and clear the session cookie.
#
# After logout:
# - Session token is marked as revoked in database
# - Session cookie is cleared (expires immediately)
# - Subsequent requests with the old cookie will return 401 Unauthorized
#
# The fp_session cookie is automatically sent by the HTTP client
###
POST {{base_url}}/api/v1/auth/sessions/logout

### STEP 6: Verify Logout - Should Return 401
### ----------------------------------------------------------------------------
# This request should fail with 401 Unauthorized
# The cookie was cleared in the logout response, so this should be rejected
###
GET {{base_url}}/api/v1/auth/sessions/me

### ============================================================================
### TOKEN MANAGEMENT (Using Admin Token)
### ============================================================================
# For API clients and programmatic access, use Personal Access Tokens (PATs).
# These are long-lived tokens that don't require CSRF protection.

### Create Setup Token (For New Users)
### ----------------------------------------------------------------------------
# @name createSetupToken
# Setup tokens can be exchanged for either:
# - Admin tokens (via /api/v1/bootstrap/initialize)
# - Session tokens (via /api/v1/auth/sessions)
#
# Use cases:
# - Onboarding new users
# - Creating session tokens for web applications
# - Temporary access tokens
###
POST {{base_url}}/api/v1/tokens
Authorization: Bearer {{admin_token}}
Content-Type: application/json

{
  "name": "setup-token-for-new-user",
  "description": "Setup token for user onboarding",
  "scopes": ["team:team-a:*"],
  "maxUsageCount": 5,
  "expiresAt": "2025-12-31T23:59:59Z"
}

@new_setup_token = {{createSetupToken.response.body.token}}

### Create Admin Token
### ----------------------------------------------------------------------------
# Requires: admin:all scope
# @name createAdminToken
###
POST {{base_url}}/api/v1/tokens
Authorization: Bearer {{admin_token}}
Content-Type: application/json

{
  "name": "second-admin",
  "description": "Another admin token",
  "scopes": ["admin:all"],
  "createdBy": "admin@example.com"
}

### Create Resource-Level Token
### ----------------------------------------------------------------------------
# Scope format: {resource}:{action}
# Resources: clusters, routes, listeners, api-definitions, tokens, teams
# Actions: read, write, delete
###
POST {{base_url}}/api/v1/tokens
Authorization: Bearer {{admin_token}}
Content-Type: application/json

{
  "name": "resource-token",
  "description": "Token with resource-level access",
  "scopes": [
    "clusters:read",
    "clusters:write",
    "routes:read",
    "routes:write"
  ],
  "createdBy": "admin@example.com"
}

### Create Team-Scoped Token
### ----------------------------------------------------------------------------
# Scope format: team:{team_name}:{resource}:{action}
# OR team:{team_name}:* for full team access
# @name createTeamToken
###
POST {{base_url}}/api/v1/tokens
Authorization: Bearer {{admin_token}}
Content-Type: application/json

{
  "name": "team-a-token",
  "description": "Token scoped to team-a resources",
  "scopes": [
    "team:team-a:routes:read",
    "team:team-a:routes:write",
    "team:team-a:listeners:read",
    "team:team-a:listeners:write"
  ],
  "createdBy": "admin@example.com",
  "expiresAt": "2025-12-31T23:59:59Z"
}

### Create Multi-Team Token
### ----------------------------------------------------------------------------
# A single token can have access to multiple teams
###
POST {{base_url}}/api/v1/tokens
Authorization: Bearer {{admin_token}}
Content-Type: application/json

{
  "name": "multi-team-token",
  "description": "Token with access to multiple teams",
  "scopes": [
    "team:team-a:*",              // Full access to team-a
    "team:team-b:routes:read",    // Read-only routes for team-b
    "team:team-c:clusters:read"   // Read-only clusters for team-c
  ],
  "createdBy": "admin@example.com"
}

### Extract token ID from response
@token_id = {{createTeamToken.response.body.id}}

### ============================================================================
### TOKEN OPERATIONS
### ============================================================================

### List All Tokens
GET {{base_url}}/api/v1/tokens
Authorization: Bearer {{admin_token}}

### List Tokens with Pagination
GET {{base_url}}/api/v1/tokens?limit=10&offset=0
Authorization: Bearer {{admin_token}}

### Get Token by ID
GET {{base_url}}/api/v1/tokens/{{token_id}}
Authorization: Bearer {{admin_token}}

### Update Token
### ----------------------------------------------------------------------------
# Can update: name, description, status, scopes, expiresAt
###
PATCH {{base_url}}/api/v1/tokens/{{token_id}}
Authorization: Bearer {{admin_token}}
Content-Type: application/json

{
  "description": "Updated description with new purpose",
  "scopes": [
    "team:team-a:routes:read",
    "team:team-a:routes:write",
    "team:team-a:clusters:read"
  ]
}

### Rotate Token (Generate New Secret)
### ----------------------------------------------------------------------------
# Returns new token with same ID but new secret
# Old secret is immediately invalidated
###
POST {{base_url}}/api/v1/tokens/{{token_id}}/rotate
Authorization: Bearer {{admin_token}}

### Revoke Token (Soft Delete)
### ----------------------------------------------------------------------------
# Permanently invalidates the token
# Sets status to 'revoked', clears scopes
###
DELETE {{base_url}}/api/v1/tokens/{{token_id}}
Authorization: Bearer {{admin_token}}

### ============================================================================
### SCOPE HIERARCHY & EXAMPLES
### ============================================================================

### Scope Format:
# admin:all                           - Full admin access, bypasses all checks
# {resource}:{action}                 - Resource-level access (e.g., "routes:read")
# team:{name}:{resource}:{action}     - Team-scoped access (e.g., "team:acme:routes:write")
# team:{name}:*                       - Full access to all team resources

### Available Resources:
# - clusters           (Envoy clusters/upstreams)
# - routes             (HTTP routes)
# - listeners          (Envoy listeners)
# - api-definitions    (OpenAPI/Platform API definitions)
# - tokens             (Token management)
# - teams              (Team resources)

### Available Actions:
# - read               (GET requests)
# - write              (POST, PUT, PATCH requests)
# - delete             (DELETE requests)

### Example: Token with Mixed Scope Levels
POST {{base_url}}/api/v1/tokens
Authorization: Bearer {{admin_token}}
Content-Type: application/json

{
  "name": "mixed-scope-token",
  "description": "Token demonstrating scope hierarchy",
  "scopes": [
    "clusters:read",                      // Can read ALL clusters
    "team:team-a:routes:write",           // Can write only team-a routes
    "team:team-b:listeners:read",         // Can read only team-b listeners
    "team:team-c:api-definitions:read"    // Can read only team-c API definitions
  ]
}

### ============================================================================
### CORS & WEB INTEGRATION
### ============================================================================

### Configure CORS Origin
# Set environment variable: FLOWPLANE_UI_ORIGIN
# Example: export FLOWPLANE_UI_ORIGIN=https://app.example.com
# Default: http://localhost:3000 (for development)

### Preflight Request (OPTIONS)
### ----------------------------------------------------------------------------
# Browsers send this automatically before actual requests
# to check CORS permissions
###
OPTIONS {{base_url}}/api/v1/auth/sessions
Origin: http://localhost:3000
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Content-Type, X-CSRF-Token

### Cross-Origin Request with Credentials
### ----------------------------------------------------------------------------
# When making requests from a web application:
# 1. Set credentials: 'include' in fetch options
# 2. Include X-CSRF-Token header for state-changing requests
# 3. Session cookie is sent automatically
###

### Example JavaScript fetch:
# ```javascript
# // Create session
# const response = await fetch('http://localhost:8080/api/v1/auth/sessions', {
#   method: 'POST',
#   credentials: 'include',  // Important: include cookies (fp_session cookie)
#   headers: {
#     'Content-Type': 'application/json'
#   },
#   body: JSON.stringify({
#     setupToken: 'fp_setup_...'
#   })
# });
#
# const data = await response.json();
# // CSRF token is available in both the response header and body
# const csrfToken = data.csrfToken;  // or response.headers.get('x-csrf-token')
# const sessionId = data.sessionId;
# const teams = data.teams;
# const scopes = data.scopes;
#
# // The fp_session cookie is now stored automatically by the browser
# // and will be sent with all subsequent requests
#
# // Make authenticated request with CSRF token
# await fetch('http://localhost:8080/api/v1/clusters', {
#   method: 'POST',
#   credentials: 'include',  // Include session cookie automatically
#   headers: {
#     'Content-Type': 'application/json',
#     'X-CSRF-Token': csrfToken  // Required for state-changing requests
#   },
#   body: JSON.stringify({
#     name: 'my-cluster',
#     endpoints: [{ host: 'api.example.com', port: 443 }]
#   })
# });
# ```

### ============================================================================
### TROUBLESHOOTING & COMMON SCENARIOS
### ============================================================================

### Scenario 1: "CSRF token required" Error
# Solution: Include X-CSRF-Token header for POST/PUT/PATCH/DELETE requests
# The session cookie is sent automatically
POST {{base_url}}/api/v1/clusters
X-CSRF-Token: {{csrf_token}}
Content-Type: application/json

{
  "name": "test-cluster",
  "endpoints": [{"host": "localhost", "port": 8080}]
}

### Scenario 2: "Forbidden" Error with Valid Token
# Possible causes:
# - Token doesn't have required scope
# - Team-scoped token accessing wrong team's resources
# - Token has been revoked
#
# Check token scopes:
GET {{base_url}}/api/v1/tokens/{{token_id}}
Authorization: Bearer {{admin_token}}

### Scenario 3: Session Expired
# Sessions expire after 24 hours
# Create a new session using the same setup token (if max_usage_count allows)
POST {{base_url}}/api/v1/auth/sessions
Content-Type: application/json

{
  "setupToken": "{{setup_token}}"
}

### Scenario 4: Testing with curl
# Create session:
# curl -X POST http://localhost:8080/api/v1/auth/sessions \
#   -H "Content-Type: application/json" \
#   -d '{"setupToken":"fp_setup_..."}' \
#   -c cookies.txt \
#   -v
#
# Response includes:
# - Set-Cookie header with fp_session=fp_session_{uuid}.{secret}
# - X-CSRF-Token header with CSRF token
# - Response body with sessionId, csrfToken, teams, scopes, expiresAt
#
# Extract CSRF token from response body:
# CSRF_TOKEN=$(curl -s -X POST http://localhost:8080/api/v1/auth/sessions \
#   -H "Content-Type: application/json" \
#   -d '{"setupToken":"fp_setup_..."}' \
#   -c cookies.txt | jq -r '.csrfToken')
#
# Make authenticated request with cookie and CSRF token:
# curl -X POST http://localhost:8080/api/v1/clusters \
#   -b cookies.txt \
#   -H "Content-Type: application/json" \
#   -H "X-CSRF-Token: $CSRF_TOKEN" \
#   -d '{"name":"test","endpoints":[{"host":"localhost","port":8080}]}'

### ============================================================================
### SECURITY BEST PRACTICES
### ============================================================================

### 1. Token Storage
# - Admin/PAT tokens: Store securely (environment variables, secrets manager)
# - Session tokens: Stored in HttpOnly cookies (browser handles automatically)
# - CSRF tokens: Store in JavaScript variable, NOT in cookie

### 2. Token Rotation
# Rotate admin tokens periodically:
POST {{base_url}}/api/v1/tokens/{{token_id}}/rotate
Authorization: Bearer {{admin_token}}

### 3. Least Privilege
# Create tokens with minimal required scopes:
POST {{base_url}}/api/v1/tokens
Authorization: Bearer {{admin_token}}
Content-Type: application/json

{
  "name": "read-only-token",
  "description": "Read-only access to team-a routes",
  "scopes": ["team:team-a:routes:read"]
}

### 4. Token Expiration
# Set expiration for temporary access:
POST {{base_url}}/api/v1/tokens
Authorization: Bearer {{admin_token}}
Content-Type: application/json

{
  "name": "temp-token",
  "description": "Temporary 7-day access",
  "scopes": ["team:team-a:*"],
  "expiresAt": "2025-01-20T00:00:00Z"
}

### 5. Audit Token Usage
# Monitor token usage via audit logs
# Check last_used_at timestamp
GET {{base_url}}/api/v1/tokens
Authorization: Bearer {{admin_token}}

### ============================================================================
### END OF EXAMPLES
### ============================================================================
