//! HashiCorp Vault secrets backend implementation.
//!
//! This module provides integration with HashiCorp Vault's KV v2 secrets engine
//! and PKI secrets engine for mTLS certificate generation.
//!
//! It implements the [`SecretsClient`] trait to provide secure, centralized secrets
//! management with versioning, audit logging, and access control.
//!
//! # Configuration
//!
//! Vault integration requires:
//! - Vault server address (HTTPS recommended)
//! - Authentication token or AppRole credentials
//! - Optional namespace for multi-tenancy
//! - KV v2 mount path (default: "secret")
//!
//! For PKI/mTLS certificate generation, additional configuration via environment:
//! - `FLOWPLANE_VAULT_PKI_MOUNT_PATH`: PKI engine mount path (enables mTLS if set)
//! - `FLOWPLANE_SPIFFE_TRUST_DOMAIN`: SPIFFE trust domain (default: "flowplane.local")
//! - `FLOWPLANE_VAULT_PKI_ROLE`: PKI role name (default: "envoy-proxy")
//!
//! # Example
//!
//! ```rust,ignore
//! use flowplane::secrets::{VaultSecretsClient, VaultConfig};
//!
//! let config = VaultConfig {
//!     address: "https://vault.example.com".to_string(),
//!     token: Some("vault-token".to_string()),
//!     namespace: Some("flowplane".to_string()),
//!     mount_path: "secret".to_string(),
//! };
//!
//! let client = VaultSecretsClient::new(config).await?;
//! let secret = client.get_secret("bootstrap_token").await?;
//! ```
//!
//! # Security
//!
//! - All communication uses TLS
//! - Tokens are never logged
//! - Audit logging enabled in Vault tracks all access
//! - Secrets are encrypted at rest in Vault
//! - KV v2 provides automatic versioning

use async_trait::async_trait;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use vaultrs::client::{VaultClient, VaultClientSettingsBuilder};
use vaultrs::kv2;

use super::client::{SecretMetadata, SecretsClient};
use super::error::{Result, SecretsError};

// ============================================================================
// PKI Configuration Types
// ============================================================================

/// Configuration for Vault PKI secrets engine.
///
/// This configuration controls mTLS certificate generation for Envoy proxies.
/// If `FLOWPLANE_VAULT_PKI_MOUNT_PATH` is not set, mTLS is disabled and the
/// control plane operates in insecure mode.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PkiConfig {
    /// PKI secrets engine mount path (e.g., "pki_int_proxies")
    pub mount_path: String,

    /// Vault PKI role name for certificate issuance
    pub role_name: String,

    /// SPIFFE trust domain for certificate identity URIs
    pub trust_domain: String,
}

impl PkiConfig {
    /// Load PKI configuration from environment variables.
    ///
    /// Returns `None` if `FLOWPLANE_VAULT_PKI_MOUNT_PATH` is not set,
    /// indicating mTLS is disabled.
    ///
    /// # Environment Variables
    ///
    /// - `FLOWPLANE_VAULT_PKI_MOUNT_PATH`: Required to enable mTLS
    /// - `FLOWPLANE_VAULT_PKI_ROLE`: Role name (default: "envoy-proxy")
    /// - `FLOWPLANE_SPIFFE_TRUST_DOMAIN`: Trust domain (default: "flowplane.local")
    pub fn from_env() -> Option<Self> {
        let mount_path = std::env::var("FLOWPLANE_VAULT_PKI_MOUNT_PATH").ok()?;

        let role_name =
            std::env::var("FLOWPLANE_VAULT_PKI_ROLE").unwrap_or_else(|_| "envoy-proxy".to_string());

        let trust_domain = std::env::var("FLOWPLANE_SPIFFE_TRUST_DOMAIN")
            .unwrap_or_else(|_| "flowplane.local".to_string());

        Some(Self { mount_path, role_name, trust_domain })
    }

    /// Check if mTLS is enabled based on environment configuration.
    pub fn is_mtls_enabled() -> bool {
        std::env::var("FLOWPLANE_VAULT_PKI_MOUNT_PATH").is_ok()
    }

    /// Build a SPIFFE URI for the given team and proxy.
    ///
    /// Format: `spiffe://{trust_domain}/team/{team}/proxy/{proxy_id}`
    pub fn build_spiffe_uri(&self, team: &str, proxy_id: &str) -> String {
        format!("spiffe://{}/team/{}/proxy/{}", self.trust_domain, team, proxy_id)
    }
}

/// Certificate bundle generated by Vault PKI.
///
/// Contains all materials needed for an Envoy proxy to establish mTLS
/// connections to the control plane.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneratedCertificate {
    /// PEM-encoded X.509 certificate
    pub certificate: String,

    /// PEM-encoded private key
    pub private_key: String,

    /// PEM-encoded CA certificate chain
    pub ca_chain: String,

    /// Certificate serial number (from Vault)
    pub serial_number: String,

    /// Certificate expiration timestamp
    pub expires_at: DateTime<Utc>,

    /// SPIFFE URI embedded in the certificate SAN
    pub spiffe_uri: String,
}

/// Parse team name from a SPIFFE URI.
///
/// URI format: `spiffe://{trust_domain}/team/{team}/proxy/{proxy_id}`
///
/// # Arguments
///
/// * `uri` - The SPIFFE URI to parse
///
/// # Returns
///
/// The team name if the URI is valid, otherwise `None`.
///
/// # Example
///
/// ```rust,ignore
/// let team = parse_team_from_spiffe_uri("spiffe://flowplane.local/team/engineering/proxy/proxy-1");
/// assert_eq!(team, Some("engineering".to_string()));
/// ```
pub fn parse_team_from_spiffe_uri(uri: &str) -> Option<String> {
    let parts: Vec<&str> = uri.split('/').collect();
    // Expected: ["spiffe:", "", "{domain}", "team", "{team}", "proxy", "{proxy_id}"]
    if parts.len() >= 5 && parts[3] == "team" {
        Some(parts[4].to_string())
    } else {
        None
    }
}

/// Parse proxy ID from a SPIFFE URI.
///
/// URI format: `spiffe://{trust_domain}/team/{team}/proxy/{proxy_id}`
///
/// # Arguments
///
/// * `uri` - The SPIFFE URI to parse
///
/// # Returns
///
/// The proxy ID if the URI is valid, otherwise `None`.
pub fn parse_proxy_id_from_spiffe_uri(uri: &str) -> Option<String> {
    let parts: Vec<&str> = uri.split('/').collect();
    // Expected: ["spiffe:", "", "{domain}", "team", "{team}", "proxy", "{proxy_id}"]
    if parts.len() >= 7 && parts[3] == "team" && parts[5] == "proxy" {
        Some(parts[6].to_string())
    } else {
        None
    }
}

/// Configuration for HashiCorp Vault backend.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VaultConfig {
    /// Vault server address (e.g., "https://vault.example.com:8200")
    pub address: String,

    /// Vault authentication token (if using token auth)
    pub token: Option<String>,

    /// Vault namespace (for Enterprise multi-tenancy)
    pub namespace: Option<String>,

    /// KV v2 mount path (default: "secret")
    #[serde(default = "default_mount_path")]
    pub mount_path: String,
}

fn default_mount_path() -> String {
    "secret".to_string()
}

impl Default for VaultConfig {
    fn default() -> Self {
        Self {
            address: "http://127.0.0.1:8200".to_string(),
            token: None,
            namespace: None,
            mount_path: default_mount_path(),
        }
    }
}

/// HashiCorp Vault secrets backend client.
///
/// Implements the [`SecretsClient`] trait using Vault's KV v2 secrets engine.
/// Provides automatic versioning, audit logging, and secure storage.
///
/// # Thread Safety
///
/// This client is `Send + Sync` and can be safely shared across async tasks.
///
/// # Example
///
/// ```rust,ignore
/// let config = VaultConfig::default();
/// let client = VaultSecretsClient::new(config).await?;
///
/// // Store a secret
/// client.set_secret("jwt_secret", "secret-value").await?;
///
/// // Retrieve it
/// let value = client.get_secret("jwt_secret").await?;
///
/// // Rotate with new value
/// let new_value = client.rotate_secret("jwt_secret").await?;
/// ```
pub struct VaultSecretsClient {
    client: VaultClient,
    mount_path: String,
}

impl VaultSecretsClient {
    /// Creates a new Vault secrets client with the given configuration.
    ///
    /// # Arguments
    ///
    /// * `config` - Vault configuration including address and credentials
    ///
    /// # Errors
    ///
    /// - [`SecretsError::ConnectionFailed`] if Vault is unreachable
    /// - [`SecretsError::AuthenticationFailed`] if credentials are invalid
    /// - [`SecretsError::ConfigError`] if configuration is invalid
    pub async fn new(config: VaultConfig) -> Result<Self> {
        // Validate configuration
        if config.address.is_empty() {
            return Err(SecretsError::config_error("Vault address cannot be empty"));
        }

        // Build Vault client settings
        let mut settings_builder = VaultClientSettingsBuilder::default();
        settings_builder.address(&config.address);

        if let Some(ref token) = config.token {
            settings_builder.token(token);
        }

        if let Some(namespace) = config.namespace {
            settings_builder.namespace(Some(namespace));
        }

        let settings = settings_builder.build().map_err(|e| {
            SecretsError::config_error(format!("Invalid Vault configuration: {}", e))
        })?;

        // Create Vault client
        let client = VaultClient::new(settings).map_err(|e| {
            SecretsError::connection_failed(format!("Failed to create Vault client: {}", e))
        })?;

        // Test connection by checking Vault health
        match vaultrs::sys::health(&client).await {
            Ok(_) => {
                tracing::info!(address = %config.address, "Successfully connected to Vault");
            }
            Err(e) => {
                tracing::error!(error = %e, address = %config.address, "Failed to connect to Vault");
                return Err(SecretsError::connection_failed(format!(
                    "Vault health check failed: {}",
                    e
                )));
            }
        }

        Ok(Self { client, mount_path: config.mount_path.clone() })
    }

    /// Creates a Vault client from environment variables.
    ///
    /// Reads configuration from:
    /// - `VAULT_ADDR`: Vault server address
    /// - `VAULT_TOKEN`: Authentication token
    /// - `VAULT_NAMESPACE`: Optional namespace
    /// - `VAULT_MOUNT_PATH`: Optional mount path (default: "secret")
    ///
    /// # Errors
    ///
    /// - [`SecretsError::ConfigError`] if required env vars are missing
    pub async fn from_env() -> Result<Self> {
        let address = std::env::var("VAULT_ADDR")
            .map_err(|_| SecretsError::config_error("VAULT_ADDR environment variable not set"))?;

        let token = std::env::var("VAULT_TOKEN").ok();
        let namespace = std::env::var("VAULT_NAMESPACE").ok();
        let mount_path = std::env::var("VAULT_MOUNT_PATH").unwrap_or_else(|_| "secret".to_string());

        let config = VaultConfig { address, token, namespace, mount_path };

        Self::new(config).await
    }

    /// Generate a certificate for an Envoy proxy with SPIFFE identity.
    ///
    /// This method issues a certificate via Vault's PKI secrets engine with
    /// a SPIFFE URI embedded in the Subject Alternative Name (SAN).
    ///
    /// # Arguments
    ///
    /// * `pki_config` - PKI engine configuration (mount path, role, trust domain)
    /// * `team` - Team name (used in SPIFFE URI)
    /// * `proxy_id` - Unique identifier for the proxy instance
    ///
    /// # Returns
    ///
    /// Certificate bundle containing cert, private key, CA chain, and metadata.
    ///
    /// # Errors
    ///
    /// - [`SecretsError::BackendError`] if Vault PKI fails to issue certificate
    ///
    /// # Example
    ///
    /// ```rust,ignore
    /// let pki_config = PkiConfig::from_env().expect("PKI not configured");
    /// let cert = client.generate_proxy_certificate(&pki_config, "engineering", "proxy-1").await?;
    /// ```
    pub async fn generate_proxy_certificate(
        &self,
        pki_config: &PkiConfig,
        team: &str,
        proxy_id: &str,
    ) -> Result<GeneratedCertificate> {
        use vaultrs::pki::cert;

        let spiffe_uri = pki_config.build_spiffe_uri(team, proxy_id);

        tracing::info!(
            team = %team,
            proxy_id = %proxy_id,
            spiffe_uri = %spiffe_uri,
            pki_mount = %pki_config.mount_path,
            role = %pki_config.role_name,
            "Generating proxy certificate via Vault PKI"
        );

        // Build certificate generation options
        let mut opts = vaultrs::api::pki::requests::GenerateCertificateRequestBuilder::default();
        // uri_sans expects a comma-separated string for multiple SANs
        opts.uri_sans(spiffe_uri.clone());
        opts.ttl("720h"); // 30 days

        // Generate certificate via Vault PKI
        let response = cert::generate(
            &self.client,
            &pki_config.mount_path,
            &pki_config.role_name,
            Some(&mut opts),
        )
        .await
        .map_err(|e| {
            tracing::error!(
                error = %e,
                team = %team,
                proxy_id = %proxy_id,
                "Failed to generate certificate via Vault PKI"
            );
            SecretsError::backend_error(format!("Vault PKI certificate generation failed: {}", e))
        })?;

        // Parse expiration timestamp
        let expires_at = response
            .expiration
            .map(|ts| DateTime::from_timestamp(ts as i64, 0).unwrap_or_else(Utc::now))
            .unwrap_or_else(|| {
                // Default to 30 days from now if not provided
                Utc::now() + chrono::Duration::days(30)
            });

        // Build CA chain from response
        let ca_chain = response
            .ca_chain
            .map(|chain| chain.join("\n"))
            .unwrap_or_else(|| response.issuing_ca.clone());

        tracing::info!(
            team = %team,
            proxy_id = %proxy_id,
            serial_number = %response.serial_number,
            expires_at = %expires_at,
            "Successfully generated proxy certificate"
        );

        Ok(GeneratedCertificate {
            certificate: response.certificate,
            private_key: response.private_key,
            ca_chain,
            serial_number: response.serial_number,
            expires_at,
            spiffe_uri,
        })
    }
}

#[async_trait]
impl SecretsClient for VaultSecretsClient {
    async fn get_secret(&self, key: &str) -> Result<String> {
        // Read the latest version of the secret from KV v2
        let secret: HashMap<String, String> =
            kv2::read(&self.client, &self.mount_path, key).await.map_err(|e| {
                tracing::error!(error = %e, key = %key, "Failed to read secret from Vault");
                SecretsError::not_found(format!("Secret '{}' not found: {}", key, e))
            })?;

        // Extract the "value" field (our convention for storing secrets)
        secret.get("value").cloned().ok_or_else(|| {
            SecretsError::backend_error(format!("Secret '{}' has no 'value' field", key))
        })
    }

    async fn set_secret(&self, key: &str, value: &str) -> Result<()> {
        // Store secret as a map with "value" field
        let mut data = HashMap::new();
        data.insert("value".to_string(), value.to_string());

        kv2::set(&self.client, &self.mount_path, key, &data).await.map_err(|e| {
            tracing::error!(error = %e, key = %key, "Failed to write secret to Vault");
            SecretsError::backend_error(format!("Failed to store secret '{}': {}", key, e))
        })?;

        tracing::info!(key = %key, mount_path = %self.mount_path, "Successfully stored secret in Vault");
        Ok(())
    }

    async fn rotate_secret(&self, key: &str) -> Result<String> {
        // Generate a cryptographically secure random value (32 bytes = 256 bits)
        let random_bytes: Vec<u8> = {
            use rand::Rng;
            let mut rng = rand::thread_rng();
            (0..32).map(|_| rng.gen()).collect()
        };
        let new_value =
            base64::Engine::encode(&base64::engine::general_purpose::STANDARD, &random_bytes);

        // Store the new value atomically
        self.set_secret(key, &new_value).await?;

        tracing::info!(key = %key, "Successfully rotated secret in Vault");
        Ok(new_value)
    }

    async fn list_secrets(&self) -> Result<Vec<SecretMetadata>> {
        // List all keys in the KV v2 mount
        let keys: Vec<String> = kv2::list(&self.client, &self.mount_path, "")
            .await
            .map_err(|e| {
                tracing::error!(error = %e, mount_path = %self.mount_path, "Failed to list secrets from Vault");
                SecretsError::backend_error(format!("Failed to list secrets: {}", e))
            })?;

        // Fetch metadata for each key
        let mut secrets = Vec::new();
        for key in keys {
            // Read metadata for this key
            match kv2::read_metadata(&self.client, &self.mount_path, &key).await {
                Ok(metadata) => {
                    let created_time = chrono::DateTime::parse_from_rfc3339(&metadata.created_time)
                        .ok()
                        .map(|dt| dt.with_timezone(&Utc))
                        .unwrap_or_else(Utc::now);

                    let updated_time = chrono::DateTime::parse_from_rfc3339(&metadata.updated_time)
                        .ok()
                        .map(|dt| dt.with_timezone(&Utc))
                        .unwrap_or(created_time);

                    secrets.push(SecretMetadata {
                        key: key.clone(),
                        version: Some(metadata.current_version),
                        created_at: created_time,
                        updated_at: updated_time,
                        description: None,
                    });
                }
                Err(e) => {
                    tracing::warn!(error = %e, key = %key, "Failed to read metadata for secret");
                    // Continue to next secret instead of failing entirely
                }
            }
        }

        Ok(secrets)
    }

    async fn delete_secret(&self, key: &str) -> Result<()> {
        // Delete all versions of the secret (metadata delete)
        kv2::delete_metadata(&self.client, &self.mount_path, key).await.map_err(|e| {
            tracing::error!(error = %e, key = %key, "Failed to delete secret from Vault");
            SecretsError::backend_error(format!("Failed to delete secret '{}': {}", key, e))
        })?;

        tracing::info!(key = %key, mount_path = %self.mount_path, "Successfully deleted secret from Vault");
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vault_config_default() {
        let config = VaultConfig::default();
        assert_eq!(config.address, "http://127.0.0.1:8200");
        assert_eq!(config.mount_path, "secret");
        assert!(config.token.is_none());
        assert!(config.namespace.is_none());
    }

    #[test]
    fn test_vault_config_serialization() {
        let config = VaultConfig {
            address: "https://vault.example.com".to_string(),
            token: Some("token".to_string()),
            namespace: Some("ns".to_string()),
            mount_path: "kv".to_string(),
        };

        let json = serde_json::to_string(&config).unwrap();
        let deserialized: VaultConfig = serde_json::from_str(&json).unwrap();

        assert_eq!(config.address, deserialized.address);
        assert_eq!(config.token, deserialized.token);
        assert_eq!(config.namespace, deserialized.namespace);
        assert_eq!(config.mount_path, deserialized.mount_path);
    }

    // =========================================================================
    // PKI Configuration Tests
    // =========================================================================

    #[test]
    fn test_pki_config_build_spiffe_uri() {
        let config = PkiConfig {
            mount_path: "pki_int_proxies".to_string(),
            role_name: "envoy-proxy".to_string(),
            trust_domain: "flowplane.local".to_string(),
        };

        let uri = config.build_spiffe_uri("engineering", "proxy-1");
        assert_eq!(uri, "spiffe://flowplane.local/team/engineering/proxy/proxy-1");
    }

    #[test]
    fn test_pki_config_build_spiffe_uri_special_chars() {
        let config = PkiConfig {
            mount_path: "pki".to_string(),
            role_name: "proxy".to_string(),
            trust_domain: "example.com".to_string(),
        };

        // Team and proxy names with hyphens and numbers
        let uri = config.build_spiffe_uri("team-123", "proxy-abc-456");
        assert_eq!(uri, "spiffe://example.com/team/team-123/proxy/proxy-abc-456");
    }

    #[test]
    fn test_pki_config_serialization() {
        let config = PkiConfig {
            mount_path: "pki_int".to_string(),
            role_name: "my-role".to_string(),
            trust_domain: "prod.example.com".to_string(),
        };

        let json = serde_json::to_string(&config).unwrap();
        let deserialized: PkiConfig = serde_json::from_str(&json).unwrap();

        assert_eq!(config.mount_path, deserialized.mount_path);
        assert_eq!(config.role_name, deserialized.role_name);
        assert_eq!(config.trust_domain, deserialized.trust_domain);
    }

    // =========================================================================
    // SPIFFE URI Parsing Tests
    // =========================================================================

    #[test]
    fn test_parse_team_from_spiffe_uri_valid() {
        let uri = "spiffe://flowplane.local/team/engineering/proxy/proxy-1";
        assert_eq!(parse_team_from_spiffe_uri(uri), Some("engineering".to_string()));
    }

    #[test]
    fn test_parse_team_from_spiffe_uri_different_domain() {
        let uri = "spiffe://prod.example.com/team/payments/proxy/edge-gateway";
        assert_eq!(parse_team_from_spiffe_uri(uri), Some("payments".to_string()));
    }

    #[test]
    fn test_parse_team_from_spiffe_uri_team_with_hyphen() {
        let uri = "spiffe://flowplane.local/team/platform-team/proxy/p1";
        assert_eq!(parse_team_from_spiffe_uri(uri), Some("platform-team".to_string()));
    }

    #[test]
    fn test_parse_team_from_spiffe_uri_invalid_format() {
        // Missing team segment
        assert_eq!(parse_team_from_spiffe_uri("spiffe://domain/proxy/p1"), None);
        // Wrong segment name
        assert_eq!(parse_team_from_spiffe_uri("spiffe://domain/group/eng/proxy/p1"), None);
        // Empty string
        assert_eq!(parse_team_from_spiffe_uri(""), None);
        // Not a SPIFFE URI
        assert_eq!(parse_team_from_spiffe_uri("https://example.com"), None);
    }

    #[test]
    fn test_parse_proxy_id_from_spiffe_uri_valid() {
        let uri = "spiffe://flowplane.local/team/engineering/proxy/proxy-1";
        assert_eq!(parse_proxy_id_from_spiffe_uri(uri), Some("proxy-1".to_string()));
    }

    #[test]
    fn test_parse_proxy_id_from_spiffe_uri_complex_id() {
        let uri = "spiffe://flowplane.local/team/eng/proxy/k8s-pod-abc123-xyz";
        assert_eq!(parse_proxy_id_from_spiffe_uri(uri), Some("k8s-pod-abc123-xyz".to_string()));
    }

    #[test]
    fn test_parse_proxy_id_from_spiffe_uri_invalid_format() {
        // Missing proxy segment
        assert_eq!(parse_proxy_id_from_spiffe_uri("spiffe://domain/team/eng"), None);
        // Wrong segment name
        assert_eq!(parse_proxy_id_from_spiffe_uri("spiffe://domain/team/eng/node/n1"), None);
    }

    #[test]
    fn test_spiffe_uri_roundtrip() {
        let config = PkiConfig {
            mount_path: "pki".to_string(),
            role_name: "proxy".to_string(),
            trust_domain: "flowplane.local".to_string(),
        };

        let team = "payments";
        let proxy_id = "edge-proxy-1";

        let uri = config.build_spiffe_uri(team, proxy_id);

        // Parse should return the original values
        assert_eq!(parse_team_from_spiffe_uri(&uri), Some(team.to_string()));
        assert_eq!(parse_proxy_id_from_spiffe_uri(&uri), Some(proxy_id.to_string()));
    }
}
