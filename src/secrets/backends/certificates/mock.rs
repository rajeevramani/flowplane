//! Mock certificate backend for testing.
//!
//! This module provides a mock implementation of `CertificateBackend` that
//! generates deterministic test certificates without requiring a real PKI backend.

use super::backend::{CertificateBackend, CertificateBackendType};
use crate::secrets::error::{Result, SecretsError};
use crate::secrets::types::SecretString;
use crate::secrets::vault::{validate_spiffe_component, GeneratedCertificate};
use async_trait::async_trait;
use chrono::{Duration, Utc};
use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
use std::sync::Arc;

/// Mock certificate backend for testing.
///
/// This backend generates deterministic certificates with mock PEM content.
/// It supports failure injection for testing error handling paths.
///
/// # Features
///
/// - **Deterministic**: Generates predictable certificates for test assertions
/// - **Failure injection**: Can be configured to fail on next call
/// - **Metrics**: Tracks number of certificates generated
/// - **No external dependencies**: Works without any PKI infrastructure
///
/// # Example
///
/// ```rust,ignore
/// use flowplane::secrets::backends::certificates::MockCertificateBackend;
///
/// let backend = MockCertificateBackend::new("test.local");
///
/// // Generate a certificate
/// let cert = backend.generate_certificate("engineering", "proxy-1", Some(24)).await?;
/// assert!(cert.spiffe_uri.contains("engineering"));
///
/// // Inject a failure
/// backend.set_fail_next(true);
/// let result = backend.generate_certificate("team", "proxy-2", None).await;
/// assert!(result.is_err());
/// ```
#[derive(Debug)]
pub struct MockCertificateBackend {
    trust_domain: String,
    fail_next: Arc<AtomicBool>,
    generated_count: Arc<AtomicUsize>,
}

impl MockCertificateBackend {
    /// Create a new mock certificate backend.
    ///
    /// # Arguments
    ///
    /// * `trust_domain` - The SPIFFE trust domain to use in generated certificates
    pub fn new(trust_domain: impl Into<String>) -> Self {
        Self {
            trust_domain: trust_domain.into(),
            fail_next: Arc::new(AtomicBool::new(false)),
            generated_count: Arc::new(AtomicUsize::new(0)),
        }
    }

    /// Configure the backend to fail on the next operation.
    ///
    /// This is useful for testing error handling paths. The failure flag
    /// is automatically reset after the next operation fails.
    ///
    /// # Arguments
    ///
    /// * `fail` - If true, the next operation will fail
    pub fn set_fail_next(&self, fail: bool) {
        self.fail_next.store(fail, Ordering::SeqCst);
    }

    /// Get the number of certificates generated by this backend.
    ///
    /// Useful for test assertions to verify certificate generation was called.
    pub fn generated_count(&self) -> usize {
        self.generated_count.load(Ordering::SeqCst)
    }

    /// Reset the generated count to zero.
    pub fn reset_count(&self) {
        self.generated_count.store(0, Ordering::SeqCst);
    }

    /// Build a SPIFFE URI for the given team and proxy_id (legacy format).
    fn build_spiffe_uri(&self, team: &str, proxy_id: &str) -> String {
        format!("spiffe://{}/team/{}/proxy/{}", self.trust_domain, team, proxy_id)
    }

    /// Build a SPIFFE URI with optional org context.
    ///
    /// When `org` is provided:
    /// `spiffe://{trust_domain}/org/{org}/team/{team}/proxy/{proxy_id}`
    ///
    /// When `org` is `None`, uses legacy format:
    /// `spiffe://{trust_domain}/team/{team}/proxy/{proxy_id}`
    #[allow(dead_code)]
    fn build_spiffe_uri_with_org(&self, org: Option<&str>, team: &str, proxy_id: &str) -> String {
        match org {
            Some(org_val) => format!(
                "spiffe://{}/org/{}/team/{}/proxy/{}",
                self.trust_domain, org_val, team, proxy_id
            ),
            None => self.build_spiffe_uri(team, proxy_id),
        }
    }
}

impl Clone for MockCertificateBackend {
    fn clone(&self) -> Self {
        Self {
            trust_domain: self.trust_domain.clone(),
            fail_next: Arc::clone(&self.fail_next),
            generated_count: Arc::clone(&self.generated_count),
        }
    }
}

#[async_trait]
impl CertificateBackend for MockCertificateBackend {
    async fn generate_certificate(
        &self,
        team: &str,
        proxy_id: &str,
        ttl_hours: Option<u32>,
    ) -> Result<GeneratedCertificate> {
        // Check for injected failure
        if self.fail_next.swap(false, Ordering::SeqCst) {
            return Err(SecretsError::backend_error(
                "Mock certificate backend failure (injected for testing)",
            ));
        }

        // Validate inputs (same as real backends)
        validate_spiffe_component(team, "team")?;
        validate_spiffe_component(proxy_id, "proxy_id")?;

        // Increment generation count
        self.generated_count.fetch_add(1, Ordering::SeqCst);

        let spiffe_uri = self.build_spiffe_uri(team, proxy_id);
        let serial_number = format!("MOCK-{}", uuid::Uuid::new_v4());
        let ttl = ttl_hours.unwrap_or(720); // Default 30 days
        let expires_at = Utc::now() + Duration::hours(ttl as i64);

        // Generate deterministic mock PEM content
        // Format allows tests to verify team/proxy_id are embedded correctly
        let certificate = format!(
            "-----BEGIN CERTIFICATE-----\n\
             MOCK-CERT-{team}-{proxy_id}\n\
             Subject: CN=mock-proxy\n\
             SAN: URI={spiffe_uri}\n\
             Serial: {serial_number}\n\
             NotAfter: {expires_at}\n\
             -----END CERTIFICATE-----",
            team = team,
            proxy_id = proxy_id,
            spiffe_uri = spiffe_uri,
            serial_number = serial_number,
            expires_at = expires_at.format("%Y-%m-%dT%H:%M:%SZ"),
        );

        let private_key = format!(
            "-----BEGIN PRIVATE KEY-----\n\
             MOCK-PRIVATE-KEY-{team}-{proxy_id}\n\
             (This is mock key material for testing - NOT a real private key)\n\
             -----END PRIVATE KEY-----",
            team = team,
            proxy_id = proxy_id,
        );

        let ca_chain = format!(
            "-----BEGIN CERTIFICATE-----\n\
             MOCK-CA-CERTIFICATE\n\
             Issuer: CN=Mock CA, O={trust_domain}\n\
             -----END CERTIFICATE-----",
            trust_domain = self.trust_domain,
        );

        Ok(GeneratedCertificate {
            certificate,
            private_key: SecretString::new(private_key),
            ca_chain,
            serial_number,
            expires_at,
            spiffe_uri,
        })
    }

    fn backend_type(&self) -> CertificateBackendType {
        CertificateBackendType::Mock
    }

    async fn health_check(&self) -> Result<()> {
        // Check for injected failure
        if self.fail_next.swap(false, Ordering::SeqCst) {
            return Err(SecretsError::backend_error(
                "Mock health check failure (injected for testing)",
            ));
        }
        Ok(())
    }

    fn trust_domain(&self) -> &str {
        &self.trust_domain
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_mock_generate_certificate() {
        let backend = MockCertificateBackend::new("test.local");

        let cert = backend
            .generate_certificate("engineering", "proxy-1", Some(24))
            .await
            .expect("should generate certificate");

        // Verify certificate fields
        assert!(cert.certificate.contains("MOCK-CERT-engineering-proxy-1"));
        assert!(cert
            .certificate
            .contains("URI=spiffe://test.local/team/engineering/proxy/proxy-1"));
        assert_eq!(cert.spiffe_uri, "spiffe://test.local/team/engineering/proxy/proxy-1");
        assert!(cert.serial_number.starts_with("MOCK-"));

        // Verify private key is wrapped in SecretString
        assert!(cert.private_key.expose_secret().contains("MOCK-PRIVATE-KEY"));
        assert!(cert.private_key.expose_secret().contains("engineering"));

        // Verify CA chain
        assert!(cert.ca_chain.contains("MOCK-CA-CERTIFICATE"));
        assert!(cert.ca_chain.contains("test.local"));

        // Verify expiration (should be ~24 hours from now)
        let expected_expiry = Utc::now() + Duration::hours(24);
        let diff = (cert.expires_at - expected_expiry).num_seconds().abs();
        assert!(diff < 5, "Expiration should be ~24 hours from now");

        // Verify count incremented
        assert_eq!(backend.generated_count(), 1);
    }

    #[tokio::test]
    async fn test_mock_default_ttl() {
        let backend = MockCertificateBackend::new("test.local");

        let cert = backend
            .generate_certificate("team", "proxy", None) // No TTL specified
            .await
            .expect("should generate certificate");

        // Default TTL is 720 hours (30 days)
        let expected_expiry = Utc::now() + Duration::hours(720);
        let diff = (cert.expires_at - expected_expiry).num_seconds().abs();
        assert!(diff < 5, "Default TTL should be 30 days");
    }

    #[tokio::test]
    async fn test_mock_failure_injection() {
        let backend = MockCertificateBackend::new("test.local");

        // Set up failure
        backend.set_fail_next(true);

        // First call should fail
        let result = backend.generate_certificate("team", "proxy", None).await;
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("injected for testing"));

        // Second call should succeed (failure was one-time)
        let result = backend.generate_certificate("team", "proxy", None).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_mock_validates_inputs() {
        let backend = MockCertificateBackend::new("test.local");

        // Invalid team name (contains '/')
        let result = backend.generate_certificate("team/admin", "proxy", None).await;
        assert!(result.is_err());

        // Invalid proxy_id (empty)
        let result = backend.generate_certificate("team", "", None).await;
        assert!(result.is_err());

        // Valid inputs should work
        let result = backend.generate_certificate("valid-team", "valid-proxy", None).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_mock_health_check() {
        let backend = MockCertificateBackend::new("test.local");

        // Normal health check
        assert!(backend.health_check().await.is_ok());

        // Injected failure
        backend.set_fail_next(true);
        assert!(backend.health_check().await.is_err());

        // Back to normal
        assert!(backend.health_check().await.is_ok());
    }

    #[test]
    fn test_mock_backend_type() {
        let backend = MockCertificateBackend::new("test.local");
        assert_eq!(backend.backend_type(), CertificateBackendType::Mock);
    }

    #[test]
    fn test_mock_trust_domain() {
        let backend = MockCertificateBackend::new("custom.domain");
        assert_eq!(backend.trust_domain(), "custom.domain");
    }

    #[tokio::test]
    async fn test_mock_count_tracking() {
        let backend = MockCertificateBackend::new("test.local");

        assert_eq!(backend.generated_count(), 0);

        backend.generate_certificate("a", "p1", None).await.unwrap();
        assert_eq!(backend.generated_count(), 1);

        backend.generate_certificate("b", "p2", None).await.unwrap();
        assert_eq!(backend.generated_count(), 2);

        backend.reset_count();
        assert_eq!(backend.generated_count(), 0);
    }

    #[test]
    fn test_mock_is_clone() {
        let backend1 = MockCertificateBackend::new("test.local");
        backend1.set_fail_next(true);

        let backend2 = backend1.clone();

        // Clones should share state
        assert!(backend2.fail_next.load(Ordering::SeqCst));
    }

    #[test]
    fn test_mock_is_debug() {
        let backend = MockCertificateBackend::new("test.local");
        let debug_output = format!("{:?}", backend);
        assert!(debug_output.contains("MockCertificateBackend"));
        assert!(debug_output.contains("test.local"));
    }
}
